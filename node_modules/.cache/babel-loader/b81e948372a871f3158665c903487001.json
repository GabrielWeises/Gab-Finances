{"ast":null,"code":"import { belongsTo, createServer, Model } from \"miragejs\";\nimport jwt from \"jsonwebtoken\";\nimport { hashSync, compareSync } from \"bcryptjs\";\nconst SECRET_KEY = \"123456\";\nexport function makeServer() {\n  createServer({\n    models: {\n      transaction: Model.extend({\n        user: belongsTo(\"user\")\n      }),\n      user: Model\n    },\n\n    seeds(server) {\n      server.db.loadData({\n        transactions: [{\n          id: 1,\n          title: \"Freelance de website\",\n          type: \"deposit\",\n          category: \"Dev\",\n          amount: 6000,\n          createdAt: new Date(\"2021-02-12 09:00:00\"),\n          userId: 1\n        }, {\n          id: 2,\n          title: \"Aluguel\",\n          type: \"withdraw\",\n          category: \"Casa\",\n          amount: 1100,\n          createdAt: new Date(\"2021-02-14 11:00:00\"),\n          userId: 1\n        }],\n        users: [{\n          id: 1,\n          username: \"admin\",\n          password: hashSync(\"admin\", 8)\n        }]\n      });\n    },\n\n    routes() {\n      this.namespace = \"api\";\n      this.post(\"/auth\", (schema, request) => {\n        const data = JSON.parse(request.requestBody);\n        const user = schema.all(\"user\").models.find(model => model.attrs.username === data.username);\n\n        if (!user) {\n          return {\n            error: \"Não existe um usuário com esse nome.\"\n          };\n        }\n\n        const validatedPassword = compareSync(data.password, user.attrs.password);\n\n        if (!validatedPassword) {\n          return {\n            error: \"Não existe um usuário com esse nome\"\n          };\n        }\n\n        const token = jwt.sign({\n          username: data.username\n        }, SECRET_KEY);\n        return {\n          user: {\n            username: data.username,\n            token\n          }\n        };\n      });\n      this.post(\"/signup\", (schema, request) => {\n        const data = JSON.parse(request.requestBody);\n        const user = schema.all(\"user\").models.find(model => model.attrs.username === data.username);\n\n        if (user) {\n          return {\n            error: \"Já existe um usuário com esse nome.\"\n          };\n        }\n\n        const newPassword = hashSync(data.password, 8);\n        schema.create(\"user\", { ...data,\n          password: newPassword\n        });\n        const token = jwt.sign({\n          username: data.username\n        }, SECRET_KEY);\n        return {\n          user: {\n            username: data.username,\n            token\n          }\n        };\n      });\n      this.get(\"/transactions\", (schema, request) => {\n        const {\n          username,\n          token\n        } = request.requestHeaders;\n        const parsedToken = jwt.verify(token, SECRET_KEY);\n\n        if (parsedToken.username !== username) {\n          return {\n            error: \"Envie um token.\"\n          };\n        }\n\n        const user = schema.all(\"user\").models.find(model => model.attrs.username === username);\n        const transactions = schema.all(\"transaction\").models.filter(transaction => transaction.attrs.userId === parseInt(user.id));\n        return {\n          transactions\n        };\n      });\n      this.post(\"/transactions\", (schema, request) => {\n        const data = JSON.parse(request.requestBody);\n        const {\n          username,\n          token\n        } = request.requestHeaders;\n        const parsedToken = jwt.verify(token, SECRET_KEY);\n\n        if (parsedToken.username !== username) {\n          return {\n            error: \"Envie um token.\"\n          };\n        }\n\n        const user = schema.all(\"user\").models.find(model => model.attrs.username === username);\n        return schema.create(\"transaction\", { ...data,\n          createdAt: new Date(),\n          userId: parseInt(user.id)\n        });\n      });\n    }\n\n  });\n}","map":{"version":3,"sources":["/Users/rayssamel/Downloads/dt-money-master/src/mirage/index.ts"],"names":["belongsTo","createServer","Model","jwt","hashSync","compareSync","SECRET_KEY","makeServer","models","transaction","extend","user","seeds","server","db","loadData","transactions","id","title","type","category","amount","createdAt","Date","userId","users","username","password","routes","namespace","post","schema","request","data","JSON","parse","requestBody","all","find","model","attrs","error","validatedPassword","token","sign","newPassword","create","get","requestHeaders","parsedToken","verify","filter","parseInt"],"mappings":"AAAA,SAASA,SAAT,EAAoBC,YAApB,EAAkCC,KAAlC,QAA+C,UAA/C;AACA,OAAOC,GAAP,MAAgB,cAAhB;AACA,SAASC,QAAT,EAAmBC,WAAnB,QAAsC,UAAtC;AAEA,MAAMC,UAAU,GAAG,QAAnB;AAMA,OAAO,SAASC,UAAT,GAAsB;AAC3BN,EAAAA,YAAY,CAAC;AACXO,IAAAA,MAAM,EAAE;AACNC,MAAAA,WAAW,EAAEP,KAAK,CAACQ,MAAN,CAAa;AACxBC,QAAAA,IAAI,EAAEX,SAAS,CAAC,MAAD;AADS,OAAb,CADP;AAINW,MAAAA,IAAI,EAAET;AAJA,KADG;;AAOXU,IAAAA,KAAK,CAACC,MAAD,EAAS;AACZA,MAAAA,MAAM,CAACC,EAAP,CAAUC,QAAV,CAAmB;AACjBC,QAAAA,YAAY,EAAE,CACZ;AACEC,UAAAA,EAAE,EAAE,CADN;AAEEC,UAAAA,KAAK,EAAE,sBAFT;AAGEC,UAAAA,IAAI,EAAE,SAHR;AAIEC,UAAAA,QAAQ,EAAE,KAJZ;AAKEC,UAAAA,MAAM,EAAE,IALV;AAMEC,UAAAA,SAAS,EAAE,IAAIC,IAAJ,CAAS,qBAAT,CANb;AAOEC,UAAAA,MAAM,EAAE;AAPV,SADY,EAUZ;AACEP,UAAAA,EAAE,EAAE,CADN;AAEEC,UAAAA,KAAK,EAAE,SAFT;AAGEC,UAAAA,IAAI,EAAE,UAHR;AAIEC,UAAAA,QAAQ,EAAE,MAJZ;AAKEC,UAAAA,MAAM,EAAE,IALV;AAMEC,UAAAA,SAAS,EAAE,IAAIC,IAAJ,CAAS,qBAAT,CANb;AAOEC,UAAAA,MAAM,EAAE;AAPV,SAVY,CADG;AAqBjBC,QAAAA,KAAK,EAAE,CACL;AACER,UAAAA,EAAE,EAAE,CADN;AAEES,UAAAA,QAAQ,EAAE,OAFZ;AAGEC,UAAAA,QAAQ,EAAEvB,QAAQ,CAAC,OAAD,EAAU,CAAV;AAHpB,SADK;AArBU,OAAnB;AA6BD,KArCU;;AAsCXwB,IAAAA,MAAM,GAAG;AACP,WAAKC,SAAL,GAAiB,KAAjB;AAEA,WAAKC,IAAL,CAAU,OAAV,EAAmB,CAACC,MAAD,EAASC,OAAT,KAAqB;AACtC,cAAMC,IAAI,GAAGC,IAAI,CAACC,KAAL,CAAWH,OAAO,CAACI,WAAnB,CAAb;AAEA,cAAMzB,IAAS,GAAGoB,MAAM,CACrBM,GADe,CACX,MADW,EAEf7B,MAFe,CAER8B,IAFQ,CAEHC,KAAK,IAAIA,KAAK,CAACC,KAAN,CAAYd,QAAZ,KAAyBO,IAAI,CAACP,QAFpC,CAAlB;;AAIA,YAAI,CAACf,IAAL,EAAW;AACT,iBAAO;AACL8B,YAAAA,KAAK,EAAE;AADF,WAAP;AAGD;;AAED,cAAMC,iBAAsB,GAAGrC,WAAW,CACxC4B,IAAI,CAACN,QADmC,EAExChB,IAAI,CAAC6B,KAAL,CAAWb,QAF6B,CAA1C;;AAKA,YAAI,CAACe,iBAAL,EAAwB;AACtB,iBAAO;AACLD,YAAAA,KAAK,EAAE;AADF,WAAP;AAGD;;AAED,cAAME,KAAK,GAAGxC,GAAG,CAACyC,IAAJ,CAAS;AAAElB,UAAAA,QAAQ,EAAEO,IAAI,CAACP;AAAjB,SAAT,EAAsCpB,UAAtC,CAAd;AAEA,eAAO;AACLK,UAAAA,IAAI,EAAE;AACJe,YAAAA,QAAQ,EAAEO,IAAI,CAACP,QADX;AAEJiB,YAAAA;AAFI;AADD,SAAP;AAMD,OAhCD;AAkCA,WAAKb,IAAL,CAAU,SAAV,EAAqB,CAACC,MAAD,EAASC,OAAT,KAAqB;AACxC,cAAMC,IAAI,GAAGC,IAAI,CAACC,KAAL,CAAWH,OAAO,CAACI,WAAnB,CAAb;AAEA,cAAMzB,IAAS,GAAGoB,MAAM,CACrBM,GADe,CACX,MADW,EAEf7B,MAFe,CAER8B,IAFQ,CAEHC,KAAK,IAAIA,KAAK,CAACC,KAAN,CAAYd,QAAZ,KAAyBO,IAAI,CAACP,QAFpC,CAAlB;;AAIA,YAAIf,IAAJ,EAAU;AACR,iBAAO;AACL8B,YAAAA,KAAK,EAAE;AADF,WAAP;AAGD;;AAED,cAAMI,WAAW,GAAGzC,QAAQ,CAAC6B,IAAI,CAACN,QAAN,EAAgB,CAAhB,CAA5B;AAEAI,QAAAA,MAAM,CAACe,MAAP,CAAc,MAAd,EAAsB,EACpB,GAAGb,IADiB;AAEpBN,UAAAA,QAAQ,EAAEkB;AAFU,SAAtB;AAKA,cAAMF,KAAK,GAAGxC,GAAG,CAACyC,IAAJ,CAAS;AAAElB,UAAAA,QAAQ,EAAEO,IAAI,CAACP;AAAjB,SAAT,EAAsCpB,UAAtC,CAAd;AAEA,eAAO;AACLK,UAAAA,IAAI,EAAE;AACJe,YAAAA,QAAQ,EAAEO,IAAI,CAACP,QADX;AAEJiB,YAAAA;AAFI;AADD,SAAP;AAMD,OA5BD;AA8BA,WAAKI,GAAL,CAAS,eAAT,EAA0B,CAAChB,MAAD,EAASC,OAAT,KAAqB;AAC7C,cAAM;AAAEN,UAAAA,QAAF;AAAYiB,UAAAA;AAAZ,YAAsBX,OAAO,CAACgB,cAApC;AAEA,cAAMC,WAA+B,GAAG9C,GAAG,CAAC+C,MAAJ,CACtCP,KADsC,EAEtCrC,UAFsC,CAAxC;;AAKA,YAAI2C,WAAW,CAACvB,QAAZ,KAAyBA,QAA7B,EAAuC;AACrC,iBAAO;AACLe,YAAAA,KAAK,EAAE;AADF,WAAP;AAGD;;AAED,cAAM9B,IAAS,GAAGoB,MAAM,CACrBM,GADe,CACX,MADW,EAEf7B,MAFe,CAER8B,IAFQ,CAEHC,KAAK,IAAIA,KAAK,CAACC,KAAN,CAAYd,QAAZ,KAAyBA,QAF/B,CAAlB;AAIA,cAAMV,YAAY,GAAGe,MAAM,CACxBM,GADkB,CACd,aADc,EAElB7B,MAFkB,CAEX2C,MAFW,CAGjB1C,WAAW,IAAIA,WAAW,CAAC+B,KAAZ,CAAkBhB,MAAlB,KAA6B4B,QAAQ,CAACzC,IAAI,CAACM,EAAN,CAHnC,CAArB;AAMA,eAAO;AACLD,UAAAA;AADK,SAAP;AAGD,OA3BD;AA6BA,WAAKc,IAAL,CAAU,eAAV,EAA2B,CAACC,MAAD,EAASC,OAAT,KAAqB;AAC9C,cAAMC,IAAI,GAAGC,IAAI,CAACC,KAAL,CAAWH,OAAO,CAACI,WAAnB,CAAb;AAEA,cAAM;AAAEV,UAAAA,QAAF;AAAYiB,UAAAA;AAAZ,YAAsBX,OAAO,CAACgB,cAApC;AAEA,cAAMC,WAA+B,GAAG9C,GAAG,CAAC+C,MAAJ,CACtCP,KADsC,EAEtCrC,UAFsC,CAAxC;;AAKA,YAAI2C,WAAW,CAACvB,QAAZ,KAAyBA,QAA7B,EAAuC;AACrC,iBAAO;AACLe,YAAAA,KAAK,EAAE;AADF,WAAP;AAGD;;AAED,cAAM9B,IAAS,GAAGoB,MAAM,CACrBM,GADe,CACX,MADW,EAEf7B,MAFe,CAER8B,IAFQ,CAEHC,KAAK,IAAIA,KAAK,CAACC,KAAN,CAAYd,QAAZ,KAAyBA,QAF/B,CAAlB;AAIA,eAAOK,MAAM,CAACe,MAAP,CAAc,aAAd,EAA6B,EAClC,GAAGb,IAD+B;AAElCX,UAAAA,SAAS,EAAE,IAAIC,IAAJ,EAFuB;AAGlCC,UAAAA,MAAM,EAAE4B,QAAQ,CAACzC,IAAI,CAACM,EAAN;AAHkB,SAA7B,CAAP;AAKD,OAzBD;AA0BD;;AAhKU,GAAD,CAAZ;AAkKD","sourcesContent":["import { belongsTo, createServer, Model } from \"miragejs\";\nimport jwt from \"jsonwebtoken\";\nimport { hashSync, compareSync } from \"bcryptjs\";\n\nconst SECRET_KEY = \"123456\";\n\ninterface TokenResponseProps {\n  username: string;\n}\n\nexport function makeServer() {\n  createServer({\n    models: {\n      transaction: Model.extend({\n        user: belongsTo(\"user\")\n      }),\n      user: Model\n    },\n    seeds(server) {\n      server.db.loadData({\n        transactions: [\n          {\n            id: 1,\n            title: \"Freelance de website\",\n            type: \"deposit\",\n            category: \"Dev\",\n            amount: 6000,\n            createdAt: new Date(\"2021-02-12 09:00:00\"),\n            userId: 1\n          },\n          {\n            id: 2,\n            title: \"Aluguel\",\n            type: \"withdraw\",\n            category: \"Casa\",\n            amount: 1100,\n            createdAt: new Date(\"2021-02-14 11:00:00\"),\n            userId: 1\n          }\n        ],\n        users: [\n          {\n            id: 1,\n            username: \"admin\",\n            password: hashSync(\"admin\", 8)\n          }\n        ]\n      });\n    },\n    routes() {\n      this.namespace = \"api\";\n\n      this.post(\"/auth\", (schema, request) => {\n        const data = JSON.parse(request.requestBody);\n\n        const user: any = schema\n          .all(\"user\")\n          .models.find(model => model.attrs.username === data.username);\n\n        if (!user) {\n          return {\n            error: \"Não existe um usuário com esse nome.\"\n          };\n        }\n\n        const validatedPassword: any = compareSync(\n          data.password,\n          user.attrs.password\n        );\n\n        if (!validatedPassword) {\n          return {\n            error: \"Não existe um usuário com esse nome\"\n          };\n        }\n\n        const token = jwt.sign({ username: data.username }, SECRET_KEY);\n\n        return {\n          user: {\n            username: data.username,\n            token\n          }\n        };\n      });\n\n      this.post(\"/signup\", (schema, request) => {\n        const data = JSON.parse(request.requestBody);\n\n        const user: any = schema\n          .all(\"user\")\n          .models.find(model => model.attrs.username === data.username);\n\n        if (user) {\n          return {\n            error: \"Já existe um usuário com esse nome.\"\n          };\n        }\n\n        const newPassword = hashSync(data.password, 8);\n\n        schema.create(\"user\", {\n          ...data,\n          password: newPassword\n        });\n\n        const token = jwt.sign({ username: data.username }, SECRET_KEY);\n\n        return {\n          user: {\n            username: data.username,\n            token\n          }\n        };\n      });\n\n      this.get(\"/transactions\", (schema, request) => {\n        const { username, token } = request.requestHeaders;\n\n        const parsedToken: TokenResponseProps = jwt.verify(\n          token,\n          SECRET_KEY\n        ) as TokenResponseProps;\n\n        if (parsedToken.username !== username) {\n          return {\n            error: \"Envie um token.\"\n          };\n        }\n\n        const user: any = schema\n          .all(\"user\")\n          .models.find(model => model.attrs.username === username);\n\n        const transactions = schema\n          .all(\"transaction\")\n          .models.filter(\n            transaction => transaction.attrs.userId === parseInt(user.id)\n          );\n\n        return {\n          transactions\n        };\n      });\n\n      this.post(\"/transactions\", (schema, request) => {\n        const data = JSON.parse(request.requestBody);\n\n        const { username, token } = request.requestHeaders;\n\n        const parsedToken: TokenResponseProps = jwt.verify(\n          token,\n          SECRET_KEY\n        ) as TokenResponseProps;\n\n        if (parsedToken.username !== username) {\n          return {\n            error: \"Envie um token.\"\n          };\n        }\n\n        const user: any = schema\n          .all(\"user\")\n          .models.find(model => model.attrs.username === username);\n\n        return schema.create(\"transaction\", {\n          ...data,\n          createdAt: new Date(),\n          userId: parseInt(user.id)\n        });\n      });\n    }\n  });\n}\n"]},"metadata":{},"sourceType":"module"}